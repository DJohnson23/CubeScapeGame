// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Triangle
{
	int a;
	int b;
	int c;
};

struct Vertex {
	float3 position;
	float3 normal;
	float4 color;
};

struct TerrainVoxel
{
	int active;
	float3 localPosition;
	int3 coord;
	int typeIndex;
    float4 color;
};

struct VoxelType {
    int minHeight;
    int scale;
    float3 center;
};

RWStructuredBuffer<TerrainVoxel> voxels;
RWStructuredBuffer<VoxelType> voxelTypes;
AppendStructuredBuffer<Triangle> triangles;
AppendStructuredBuffer<Vertex> vertices;

int chunkSize;
int textureSize;

bool IsValidCoord(int3 index)
{
    return index.x < chunkSize && index.y < chunkSize && index.z < chunkSize
        && index.x >= 0 && index.y >= 0 && index.z >= 0;
}

int to1D(int x, int y, int z)
{
    int yMax = chunkSize;
    int zMax = chunkSize;

    return (x * zMax * yMax) + (y * zMax) + z;
}

int3 to3D(int idx)
{
    int yMax = chunkSize;
    int zMax = chunkSize;

    int x = idx / (zMax * yMax);
    idx -= (x * zMax * yMax);
    int y = idx / zMax;
    int z = idx % zMax;
    return int3( x, y, z );
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    TerrainVoxel voxel = voxels[to1D(id.x, id.y, id.z)];


    if (!voxel.active)
    {
        return;
    }

    /*
    for (int i = 0; i < 6; i++)
    {
        Vector3[] faceVerts = CubeMeshData.FaceVertices(i);
        Vector3 n = CubeMeshData.normals[i];

        Vector3Int offsetCoord = neighborOffsets[i];
        Vector3Int neighborCoord = new Vector3Int(voxel.coord.x + offsetCoord.x, voxel.coord.y + offsetCoord.y, voxel.coord.z + offsetCoord.z);

        if (IsValidCoord(neighborCoord))
        {
            TerrainVoxel adjacent = terrainVoxels[to1D(neighborCoord.x, neighborCoord.y, neighborCoord.z)];

            if (adjacent.active)
            {
                continue;
            }
        }

        vertices.Add(faceVerts[0] + voxel.localPosition);
        vertices.Add(faceVerts[1] + voxel.localPosition);
        vertices.Add(faceVerts[2] + voxel.localPosition);
        vertices.Add(faceVerts[3] + voxel.localPosition);

        normals.Add(n);
        normals.Add(n);
        normals.Add(n);
        normals.Add(n);

        colors.Add(voxCol);
        colors.Add(voxCol);
        colors.Add(voxCol);
        colors.Add(voxCol);

        triangles.Add(vertices.Count - 4);
        triangles.Add(vertices.Count - 3);
        triangles.Add(vertices.Count - 2);

        triangles.Add(vertices.Count - 4);
        triangles.Add(vertices.Count - 2);
        triangles.Add(vertices.Count - 1);

    }
    */
}
