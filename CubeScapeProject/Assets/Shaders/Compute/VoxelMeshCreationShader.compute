// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "../Includes/CubeMeshData.cginc"

struct Quad
{
    float3 a;
    float3 b;
    float3 c;
    float3 d;

    float3 normal;
    float4 color;
};

struct TerrainVoxel
{
	int active;
	float3 localPosition;
	int3 coord;
	int typeIndex;
    float4 color;
};

struct VoxelType {
    int minHeight;
    float scale;
    float3 center;
};

RWStructuredBuffer<TerrainVoxel> voxels;
RWStructuredBuffer<VoxelType> voxelTypes;

uint chunkSize;

AppendStructuredBuffer<Quad> quadList;

bool IsValidCoord(uint3 index)
{
    return index.x < chunkSize && index.y < chunkSize && index.z < chunkSize
        && index.x >= 0 && index.y >= 0 && index.z >= 0;
}

int to1D(int x, int y, int z)
{
    int yMax = chunkSize;
    int zMax = chunkSize;

    return (x * zMax * yMax) + (y * zMax) + z;
}

int3 to3D(int idx)
{
    int yMax = chunkSize;
    int zMax = chunkSize;

    int x = idx / (zMax * yMax);
    idx -= (x * zMax * yMax);
    int y = idx / zMax;
    int z = idx % zMax;
    return int3( x, y, z );
}

static int3 _NeighborOffsets[6] =
{
    int3(0, 0, 1),
    int3(1, 0, 0),
    int3(0, 0,-1),
    int3(-1, 0, 0),
    int3(0, 1, 0),
    int3(0,-1, 0)
};

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= chunkSize || id.y >= chunkSize || id.z >= chunkSize) {
        return;
    }

    TerrainVoxel voxel = voxels[to1D(id.x, id.y, id.z)];

    if (!voxel.active)
    {
        return;
    }

    
    for (int i = 0; i < 6; i++)
    {
        float3 faceVerts[4];
        CubeFaceVertices(faceVerts, i);
        float3 n = _CubeNormals[i];

        int3 offsetCoord = _NeighborOffsets[i];
        int3 neighborCoord = int3(voxel.coord.x + offsetCoord.x, voxel.coord.y + offsetCoord.y, voxel.coord.z + offsetCoord.z);

        if (IsValidCoord(neighborCoord))
        {
            TerrainVoxel adjacent = voxels[to1D(neighborCoord.x, neighborCoord.y, neighborCoord.z)];

            if (adjacent.active)
            {
                continue;
            }
        }

        Quad newQuad;

        newQuad.a = faceVerts[0] + voxel.localPosition;
        newQuad.b = faceVerts[1] + voxel.localPosition;
        newQuad.c = faceVerts[2] + voxel.localPosition;
        newQuad.d = faceVerts[3] + voxel.localPosition;

        newQuad.normal = n;
        newQuad.color = voxel.color;

        quadList.Append(newQuad);
    }
    
}
